---
title: EDA Analysis on TTC Bus Delay Data
jupyter:
  kernelspec:
    display_name: 'Python [conda env:base] *'
    language: python
    name: conda-base-py
---



This data was sourced from open.toronto.ca website. Raw data can be found [here](https://open.toronto.ca/dataset/ttc-bus-delay-data/).

While there are multiple years of data available on this website, we are using 2024 data.

Our goal is to see how many buses are delayed and by how much time.

Let's get started with the EDA!

```{python}
# This code block will be used for all library imports. 
import pandas as pd
import altair as alt

# Simplify working with large datasets in Altair
alt.data_transformers.enable('vegafusion')
```

## Loading and Fixing Data

```{python}
# Let's load the data.
# the Dates column is parsed through date argument to make sure it is seen as datetime object.
ttc = pd.read_csv('../data/ttc-bus-delay-data-2024.csv', parse_dates=['Date'])
```

```{python}
ttc.head()
```

```{python}
# .shape shows up how big our data is
print(f"This dataset has {ttc.shape[0]} rows and {ttc.shape[1]} columns")
ttc.shape
```

```{python}
# .info tells us about the object type for each column
# we can see 'Date' column was read as datetime object
ttc.info()
```

```{python}
# Let's also fix the 'Time' column
ttc1 = ttc.copy() # preserving the original

# Converting column to datetime object
ttc1['Time'] = pd.to_datetime(ttc['Time']).dt.time
```

Now, let's split 'Date' column into 'Date_' and 'Month' (year is not needed since this is for 2024), and convert 'Time' into 'Hours' so it more useful in the analysis later on.

```{python}
ttc1['Date_'] = ttc1['Date'].dt.date
ttc1['Month'] = ttc1['Date'].dt.month
ttc1['Hour'] = ttc1['Time'].map(lambda x: x.hour) # used ChatGPT for this conversion
```

```{python}
# Let's drop the 'Date' and 'Time' column since they are no longer needed
ttc1 = ttc1.drop(columns=['Date', 'Time'])
```

<br>

___
## Preprocessing
Now that the data is loaded in, we want to make sure we don't perform our analysis will null values. So, we will go through and identify any columns that have big number of null values and determine if they are worth keeping for analysis or not. 

```{python}
ttc1.isna().sum()
```

```{python}
# 'Direction' column has a lot null values. Let's see if these rows can be dropped
ttc1[ttc1['Direction'].isna()].head(20)
```

<br>
Maybe deleting the rows isn't such a good idea because it makes up for a lot of overall data in the dataset. Instead, let's drop the column since we already have information about the route. For that reason, it is also okay to drop 'Vehicle' column as it is not needed for our goal of observing delays in busses.

```{python}
ttc_clean = ttc1.drop(columns=['Direction', 'Vehicle'])
ttc_clean.head()
```

Now, let's look at the Route column and its NaNs. This column is particularly important for us for our goal.

```{python}
na_route = ttc1[ttc1['Route'].isna()]
na_route.head(10)
```

```{python}
# Now, we will see how many for NaN routes have delays
na_route[na_route['Min Delay'] == 0].count()
```

Since all the NaN routes have 0 delays, it is safe to drop these rows. We will also remove all other null values to ensure a clean dataset to work with

```{python}
ttc_clean = ttc_clean.dropna()
ttc_clean.isna().sum()
```

```{python}
ttc_clean.head()
```

<br>

___
## Visualizing

Now it's the fun part: visualizations!
Let's look at how the delays are distributed in this data

```{python}
# Filter data
ttc_filtered = ttc_clean[ttc_clean['Min Delay'] < 200]

# Creating histogram
delay_dist = alt.Chart(ttc_filtered).mark_bar().encode(
    alt.X('Min Delay:Q', bin=alt.Bin(maxbins=50), title='Delay (in minutes)'),
    alt.Y('count()', title='Frequency')
).properties(
    title='Distribution of Delays',
)

# Display
delay_dist
```

This plot shows that majority of the delays occur within 0 to 25 mins. This can indicate that most delays are short in duration.

Now let's take a look at top 20 routes with highest delay incidents

```{python}
# Group by 'Route' and count the occurrences
route_counts = ttc_clean.groupby('Route').size().reset_index(name='Count')

# Sort counts in descending order and get the top 20 routes
route_counts = route_counts.sort_values('Count', ascending=False)
top_routes = route_counts.head(20)
#top_routes

# Creating bar chart
top20_delay_routes = alt.Chart(top_routes).mark_bar().encode(
    alt.X('Route:N', title='Route', sort=alt.EncodingSortField(field='Count', order='descending')),  # 'N' for nominal (categorical)
    alt.Y('Count:Q', title='Count'),  # 'Q' for quantitative (numerical)
    alt.Color('Count:Q')
).properties(
    title='Top 20 Routes with Highest Delay Incidents',
)

# Display
top20_delay_routes
```

This plot shows that majority of the incidents are occuring on route 32 with close to 1,400 counts of delays, followed by route 32 and 36.
As we move towards other routes, there seems to be a smooth decline in delay counts, showing a decreasing trend.

```{python}
# Top 10 locations with Highest Delay Counts

# Filter rows where 'Min Delay' is greater than 0 (i.e., there is an actual delay)
delayed_ttc = ttc[ttc['Min Delay'] > 0]

# Group by 'Location' and count the number of delays (i.e., count occurrences where 'Min Delay' > 0)
delay_counts = delayed_ttc.groupby('Location')['Min Delay'].count().reset_index()

# Rename the column for clarity
delay_counts = delay_counts.rename(columns={'Min Delay': 'Delay Count'})

# Sort by 'Delay Count' in descending order
delay_counts_sorted = delay_counts.sort_values(by='Delay Count', ascending=False)

# Select the top 10 locations with the highest delay counts
top_10_locations = delay_counts_sorted.head(10)

# Display the top 10 locations with the highest delay counts
print(top_10_locations)
```

```{python}
# Create a bar chart of the top 10 locations with the highest delay counts
chart = alt.Chart(top_10_locations).mark_bar().encode(
    x=alt.X('Delay Count:Q', title='Delay Count'),
    y=alt.Y('Location:N', title='Location', sort='-x'),  # Sort by delay count (descending)
    color='Location:N'
).properties(
    title='Top 10 Locations with the Highest Delay Counts'
)

chart.show()
```

```{python}
# Delay Counts by Day of the Week

delay_counts_day = delayed_ttc.groupby('Day')['Min Delay'].count().reset_index()
delay_counts_day = delay_counts_day.rename(columns={'Min Delay': 'Delay Count'})
delay_counts_day = delay_counts_day.sort_values(by='Delay Count', ascending=False)
print("\nDelay Counts by Day of the Week")
print(delay_counts_day)


# Plot delay counts by Day of the Week
chart_month = alt.Chart(delay_counts_day).mark_bar().encode(
    x=alt.X('Day:O', title='Day of the Week'),
    y=alt.Y('Delay Count:Q', title='Delay Count'),
    color='Day:O'
).properties(
    title='Delay Counts by Day of the Week'
)

chart_month.show()
```

```{python}
delay_counts_incident = delayed_ttc.groupby('Incident')['Min Delay'].count().reset_index()
delay_counts_incident = delay_counts_incident.rename(columns={'Min Delay': 'Delay Count'})
delay_counts_incident = delay_counts_incident.sort_values(by='Delay Count', ascending=False)

print("Delay Counts by Incident Type")
print(delay_counts_incident)


# Visualize delay counts by Incident Type
chart_incident = alt.Chart(delay_counts_incident).mark_bar().encode(
    x=alt.X('Incident:N', title='Incident Type', sort='-y'),  # Sort by Delay Count
    y=alt.Y('Delay Count:Q', title='Delay Count'),
    color='Incident:N'
).properties(
    title='Delay Counts by Incident Type'
)

chart_incident.show()
```

```{python}
# Create a bar chart of the top 10 locations with the highest delay counts
chart = alt.Chart(top_10_locations).mark_bar().encode(
    x=alt.X('Delay Count:Q', title='Delay Count'),
    y=alt.Y('Location:N', title='Location', sort='-x'),  # Sort by delay count (descending)
    color='Location:N'
).properties(
    title='Top 10 Locations with the Highest Delay Counts'
)

chart.show()
```

```{python}
# Delay Counts by Day of the Week

delay_counts_day = delayed_ttc.groupby('Day')['Min Delay'].count().reset_index()
delay_counts_day = delay_counts_day.rename(columns={'Min Delay': 'Delay Count'})
delay_counts_day = delay_counts_day.sort_values(by='Delay Count', ascending=False)
print("\nDelay Counts by Day of the Week")
print(delay_counts_day)


# Plot delay counts by Day of the Week
chart_month = alt.Chart(delay_counts_day).mark_bar().encode(
    x=alt.X('Day:O', title='Day of the Week'),
    y=alt.Y('Delay Count:Q', title='Delay Count'),
    color='Day:O'
).properties(
    title='Delay Counts by Day of the Week'
)

chart_month.show()
```

```{python}
delay_counts_incident = delayed_ttc.groupby('Incident')['Min Delay'].count().reset_index()
delay_counts_incident = delay_counts_incident.rename(columns={'Min Delay': 'Delay Count'})
delay_counts_incident = delay_counts_incident.sort_values(by='Delay Count', ascending=False)

print("Delay Counts by Incident Type")
print(delay_counts_incident)


# Visualize delay counts by Incident Type
chart_incident = alt.Chart(delay_counts_incident).mark_bar().encode(
    x=alt.X('Incident:N', title='Incident Type', sort='-y'),  # Sort by Delay Count
    y=alt.Y('Delay Count:Q', title='Delay Count'),
    color='Incident:N'
).properties(
    title='Delay Counts by Incident Type'
)

chart_incident.show()
```


